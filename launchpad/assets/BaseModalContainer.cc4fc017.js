var mt = Object.defineProperty, gt = Object.defineProperties; var yt = Object.getOwnPropertyDescriptors; var oe = Object.getOwnPropertySymbols; var ke = Object.prototype.hasOwnProperty, Ce = Object.prototype.propertyIsEnumerable; var De = (t, o, a) => o in t ? mt(t, o, { enumerable: !0, configurable: !0, writable: !0, value: a }) : t[o] = a, h = (t, o) => { for (var a in o || (o = {})) ke.call(o, a) && De(t, a, o[a]); if (oe) for (var a of oe(o)) Ce.call(o, a) && De(t, a, o[a]); return t }, F = (t, o) => gt(t, yt(o)); var V = (t, o) => { var a = {}; for (var e in t) ke.call(t, e) && o.indexOf(e) < 0 && (a[e] = t[e]); if (t != null && oe) for (var e of oe(t)) o.indexOf(e) < 0 && Ce.call(t, e) && (a[e] = t[e]); return a }; import { a as O, u as g, x as S, y as pe, z as D, A as B, D as P, E as C, G as j, H as q, I as ht, J as xt, K as Me, L as Ve, M as N, O as St, P as R, _ as wt, f as ae, o as Ot, p as It, w as ne, g as re, b as se, n as Et, r as Tt } from "./index.28d01b6e.js"; function k(t, o, ...a) { if (t in o) { let l = o[t]; return typeof l == "function" ? l(...a) : l } let e = new Error(`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(o).map(l => `"${l}"`).join(", ")}.`); throw Error.captureStackTrace && Error.captureStackTrace(e, k), e } function I(e) { var l = e, { visible: t = !0, features: o = 0 } = l, a = V(l, ["visible", "features"]); var u; if (t || o & 2 && a.props.static) return ge(a); if (o & 1) { let d = ((u = a.props.unmount) != null ? u : !0) ? 0 : 1; return k(d, { [0]() { return null }, [1]() { return ge(F(h({}, a), { props: F(h({}, a.props), { hidden: !0, style: { display: "none" } }) })) } }) } return ge(a) } function ge({ props: t, attrs: o, slots: a, slot: e, name: l }) {
    var u; let n = z(t, ["unmount", "static"]), { as: d } = n, p = V(n, ["as"]), i = (u = a.default) == null ? void 0 : u.call(a, e); if (d === "template") {
        if (Object.keys(p).length > 0 || Object.keys(o).length > 0) {
            let [r, ...c] = i != null ? i : []; if (!Rt(r) || c.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${l} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(p).concat(Object.keys(o)).map(s => `  - ${s}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(s => `  - ${s}`).join(`
`)].join(`
`)); return St(r, p)
        } return Array.isArray(i) && i.length === 1 ? i[0] : i
    } return q(d, p, i)
} function z(t, o = []) { let a = Object.assign({}, t); for (let e of o) e in a && delete a[e]; return a } function Rt(t) { return t == null ? !1 : typeof t.type == "string" || typeof t.type == "object" || typeof t.type == "function" } var Pt = 0; function Dt() { return ++Pt } function E() { return Dt() } function kt(t) { throw new Error("Unexpected object: " + t) } function Se(t, o) { let a = o.resolveItems(); if (a.length <= 0) return null; let e = o.resolveActiveIndex(), l = e != null ? e : -1, u = (() => { switch (t.focus) { case 0: return a.findIndex(d => !o.resolveDisabled(d)); case 1: { let d = a.slice().reverse().findIndex((p, i, n) => l !== -1 && n.length - i - 1 >= l ? !1 : !o.resolveDisabled(p)); return d === -1 ? d : a.length - 1 - d } case 2: return a.findIndex((d, p) => p <= l ? !1 : !o.resolveDisabled(d)); case 3: { let d = a.slice().reverse().findIndex(p => !o.resolveDisabled(p)); return d === -1 ? d : a.length - 1 - d } case 4: return a.findIndex(d => o.resolveId(d) === t.id); case 5: return null; default: kt(t) } })(); return u === -1 ? e : u } function m(t) { return t == null || t.value == null ? null : "$el" in t.value ? t.value.$el : t.value } function M(t, o, a) { typeof window != "undefined" && P(e => { window.addEventListener(t, o, a), e(() => { window.removeEventListener(t, o, a) }) }) } var _e = Symbol("Context"); function Ct() { return G() !== null } function G() { return C(_e, null) } function Y(t) { D(_e, t) } function Be(t, o) { if (t) return t; let a = o != null ? o : "button"; if (typeof a == "string" && a.toLowerCase() === "button") return "button" } function Q(t, o) { let a = g(Be(t.value.type, t.value.as)); return B(() => { a.value = Be(t.value.type, t.value.as) }), P(() => { var e; a.value || !m(o) || m(o) instanceof HTMLButtonElement && !((e = m(o)) == null ? void 0 : e.hasAttribute("type")) && (a.value = "button") }), a } function we({ container: t, accept: o, walk: a, enabled: e }) { P(() => { let l = t.value; if (!l || e !== void 0 && !e.value) return; let u = Object.assign(p => o(p), { acceptNode: o }), d = document.createTreeWalker(l, NodeFilter.SHOW_ELEMENT, u, !1); for (; d.nextNode();)a(d.currentNode) }) } var Ne = Symbol("ComboboxContext"); function Z(t) { let o = C(Ne, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <Combobox /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, Z), a } return o } O({ name: "Combobox", emits: { "update:modelValue": t => !0 }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: !1 }, modelValue: { type: [Object, String, Number, Boolean] } }, setup(t, { slots: o, attrs: a, emit: e }) { let l = g(1), u = g(null), d = g(null), p = g(null), i = g(null), n = g({ static: !1, hold: !1 }), r = g([]), c = g(null), s = S(() => t.modelValue), v = { comboboxState: l, value: s, inputRef: d, labelRef: u, buttonRef: p, optionsRef: i, disabled: S(() => t.disabled), options: r, activeOptionIndex: c, inputPropsRef: g({ displayValue: void 0 }), optionsPropsRef: n, closeCombobox() { t.disabled || l.value !== 1 && (l.value = 1, c.value = null) }, openCombobox() { t.disabled || l.value !== 0 && (l.value = 0) }, goToOption(f, y) { if (t.disabled || i.value && !n.value.static && l.value === 1) return; let x = Se(f === 4 ? { focus: 4, id: y } : { focus: f }, { resolveItems: () => r.value, resolveActiveIndex: () => c.value, resolveId: w => w.id, resolveDisabled: w => w.dataRef.disabled }); c.value !== x && (c.value = x) }, syncInputValue() { let f = v.value.value; if (!m(v.inputRef) || f === void 0) return; let y = v.inputPropsRef.value.displayValue; typeof y == "function" ? v.inputRef.value.value = y(f) : typeof f == "string" && (v.inputRef.value.value = f) }, selectOption(f) { let y = r.value.find(w => w.id === f); if (!y) return; let { dataRef: x } = y; e("update:modelValue", x.value), v.syncInputValue() }, selectActiveOption() { if (c.value === null) return; let { dataRef: f } = r.value[c.value]; e("update:modelValue", f.value), v.syncInputValue() }, registerOption(f, y) { var x, w; let T = c.value !== null ? r.value[c.value] : null, A = Array.from((w = (x = i.value) == null ? void 0 : x.querySelectorAll('[id^="headlessui-combobox-option-"]')) != null ? w : []).reduce(($, K, _) => Object.assign($, { [K.id]: _ }), {}); r.value = [...r.value, { id: f, dataRef: y }].sort(($, K) => A[$.id] - A[K.id]), c.value = (() => T === null ? null : r.value.indexOf(T))() }, unregisterOption(f) { let y = r.value.slice(), x = c.value !== null ? y[c.value] : null, w = y.findIndex(T => T.id === f); w !== -1 && y.splice(w, 1), r.value = y, c.value = (() => w === c.value || x === null ? null : y.indexOf(x))() } }; M("mousedown", f => { var y, x, w; let T = f.target; l.value === 0 && (((y = m(d)) == null ? void 0 : y.contains(T)) || ((x = m(p)) == null ? void 0 : x.contains(T)) || ((w = m(i)) == null ? void 0 : w.contains(T)) || v.closeCombobox()) }), pe([v.value, v.inputRef], () => v.syncInputValue(), { immediate: !0 }), D(Ne, v), Y(S(() => k(l.value, { [0]: 0, [1]: 1 }))); let b = S(() => c.value === null ? null : r.value[c.value].dataRef.value); return () => { let f = { open: l.value === 0, disabled: t.disabled, activeIndex: c.value, activeOption: b.value }; return I({ props: z(t, ["modelValue", "onUpdate:modelValue", "disabled"]), slot: f, slots: o, attrs: a, name: "Combobox" }) } } }); O({ name: "ComboboxLabel", props: { as: { type: [Object, String], default: "label" } }, setup(t, { attrs: o, slots: a }) { let e = Z("ComboboxLabel"), l = `headlessui-combobox-label-${E()}`; function u() { var d; (d = m(e.inputRef)) == null || d.focus({ preventScroll: !0 }) } return () => { let d = { open: e.comboboxState.value === 0, disabled: e.disabled.value }, p = { id: l, ref: e.labelRef, onClick: u }; return I({ props: h(h({}, t), p), slot: d, attrs: o, slots: a, name: "ComboboxLabel" }) } } }); O({ name: "ComboboxButton", props: { as: { type: [Object, String], default: "button" } }, setup(t, { attrs: o, slots: a }) { let e = Z("ComboboxButton"), l = `headlessui-combobox-button-${E()}`; function u(i) { e.disabled.value || (e.comboboxState.value === 0 ? e.closeCombobox() : (i.preventDefault(), e.openCombobox()), R(() => { var n; return (n = m(e.inputRef)) == null ? void 0 : n.focus({ preventScroll: !0 }) })) } function d(i) { switch (i.key) { case "ArrowDown": i.preventDefault(), i.stopPropagation(), e.comboboxState.value === 1 && (e.openCombobox(), R(() => { e.value.value || e.goToOption(0) })), R(() => { var n; return (n = e.inputRef.value) == null ? void 0 : n.focus({ preventScroll: !0 }) }); return; case "ArrowUp": i.preventDefault(), i.stopPropagation(), e.comboboxState.value === 1 && (e.openCombobox(), R(() => { e.value.value || e.goToOption(3) })), R(() => { var n; return (n = e.inputRef.value) == null ? void 0 : n.focus({ preventScroll: !0 }) }); return; case "Escape": i.preventDefault(), e.optionsRef.value && !e.optionsPropsRef.value.static && i.stopPropagation(), e.closeCombobox(), R(() => { var n; return (n = e.inputRef.value) == null ? void 0 : n.focus({ preventScroll: !0 }) }); return } } let p = Q(S(() => ({ as: t.as, type: o.type })), e.buttonRef); return () => { var i, n; let r = { open: e.comboboxState.value === 0, disabled: e.disabled.value }, c = { ref: e.buttonRef, id: l, type: p.value, tabindex: "-1", "aria-haspopup": !0, "aria-controls": (i = m(e.optionsRef)) == null ? void 0 : i.id, "aria-expanded": e.disabled.value ? void 0 : e.comboboxState.value === 0, "aria-labelledby": e.labelRef.value ? [(n = m(e.labelRef)) == null ? void 0 : n.id, l].join(" ") : void 0, disabled: e.disabled.value === !0 ? !0 : void 0, onKeydown: d, onClick: u }; return I({ props: h(h({}, t), c), slot: r, attrs: o, slots: a, name: "ComboboxButton" }) } } }); O({ name: "ComboboxInput", props: { as: { type: [Object, String], default: "input" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, displayValue: { type: Function } }, emits: { change: t => !0 }, setup(t, { emit: o, attrs: a, slots: e }) { let l = Z("ComboboxInput"), u = `headlessui-combobox-input-${E()}`; l.inputPropsRef = S(() => t); function d(i) { switch (i.key) { case "Enter": i.preventDefault(), i.stopPropagation(), l.selectActiveOption(), l.closeCombobox(); break; case "ArrowDown": return i.preventDefault(), i.stopPropagation(), k(l.comboboxState.value, { [0]: () => l.goToOption(2), [1]: () => { l.openCombobox(), R(() => { l.value.value || l.goToOption(0) }) } }); case "ArrowUp": return i.preventDefault(), i.stopPropagation(), k(l.comboboxState.value, { [0]: () => l.goToOption(1), [1]: () => { l.openCombobox(), R(() => { l.value.value || l.goToOption(3) }) } }); case "Home": case "PageUp": return i.preventDefault(), i.stopPropagation(), l.goToOption(0); case "End": case "PageDown": return i.preventDefault(), i.stopPropagation(), l.goToOption(3); case "Escape": i.preventDefault(), l.optionsRef.value && !l.optionsPropsRef.value.static && i.stopPropagation(), l.closeCombobox(); break; case "Tab": l.selectActiveOption(), l.closeCombobox(); break } } function p(i) { l.openCombobox(), o("change", i) } return () => { var i, n, r, c, s; let v = { open: l.comboboxState.value === 0 }, b = { "aria-controls": (i = l.optionsRef.value) == null ? void 0 : i.id, "aria-expanded": l.disabled ? void 0 : l.comboboxState.value === 0, "aria-activedescendant": l.activeOptionIndex.value === null || (n = l.options.value[l.activeOptionIndex.value]) == null ? void 0 : n.id, "aria-labelledby": (s = (r = m(l.labelRef)) == null ? void 0 : r.id) != null ? s : (c = m(l.buttonRef)) == null ? void 0 : c.id, id: u, onKeydown: d, onChange: p, onInput: p, role: "combobox", type: "text", tabIndex: 0, ref: l.inputRef }, f = z(t, ["displayValue"]); return I({ props: h(h({}, f), b), slot: v, attrs: a, slots: e, features: 3, name: "ComboboxInput" }) } } }); O({ name: "ComboboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, hold: { type: [Boolean], default: !1 } }, setup(t, { attrs: o, slots: a }) { let e = Z("ComboboxOptions"), l = `headlessui-combobox-options-${E()}`; P(() => { e.optionsPropsRef.value.static = t.static }), P(() => { e.optionsPropsRef.value.hold = t.hold }); let u = G(), d = S(() => u !== null ? u.value === 0 : e.comboboxState.value === 0); return we({ container: S(() => m(e.optionsRef)), enabled: S(() => e.comboboxState.value === 0), accept(p) { return p.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : p.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT }, walk(p) { p.setAttribute("role", "none") } }), () => { var p, i, n, r; let c = { open: e.comboboxState.value === 0 }, s = { "aria-activedescendant": e.activeOptionIndex.value === null || (p = e.options.value[e.activeOptionIndex.value]) == null ? void 0 : p.id, "aria-labelledby": (r = (i = m(e.labelRef)) == null ? void 0 : i.id) != null ? r : (n = m(e.buttonRef)) == null ? void 0 : n.id, id: l, ref: e.optionsRef, role: "listbox" }, v = z(t, ["hold"]); return I({ props: h(h({}, v), s), slot: c, attrs: o, slots: a, features: 3, visible: d.value, name: "ComboboxOptions" }) } } }); O({ name: "ComboboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 } }, setup(t, { slots: o, attrs: a }) { let e = Z("ComboboxOption"), l = `headlessui-combobox-option-${E()}`, u = S(() => e.activeOptionIndex.value !== null ? e.options.value[e.activeOptionIndex.value].id === l : !1), d = S(() => N(e.value.value) === N(t.value)), p = S(() => ({ disabled: t.disabled, value: t.value })); B(() => e.registerOption(l, p)), j(() => e.unregisterOption(l)), B(() => { pe([e.comboboxState, d], () => { e.comboboxState.value === 0 && (!d.value || e.goToOption(4, l)) }, { immediate: !0 }) }), P(() => { e.comboboxState.value === 0 && (!u.value || R(() => { var s, v; return (v = (s = document.getElementById(l)) == null ? void 0 : s.scrollIntoView) == null ? void 0 : v.call(s, { block: "nearest" }) })) }); function i(s) { if (t.disabled) return s.preventDefault(); e.selectOption(l), e.closeCombobox(), R(() => { var v; return (v = m(e.inputRef)) == null ? void 0 : v.focus({ preventScroll: !0 }) }) } function n() { if (t.disabled) return e.goToOption(5); e.goToOption(4, l) } function r() { t.disabled || u.value || e.goToOption(4, l) } function c() { t.disabled || !u.value || e.optionsPropsRef.value.hold || e.goToOption(5) } return () => { let { disabled: s } = t, v = { active: u.value, selected: d.value, disabled: s }, b = { id: l, role: "option", tabIndex: s === !0 ? void 0 : -1, "aria-disabled": s === !0 ? !0 : void 0, "aria-selected": d.value === !0 ? d.value : void 0, disabled: void 0, onClick: i, onFocus: n, onPointermove: r, onMousemove: r, onPointerleave: c, onMouseleave: c }; return I({ props: h(h({}, t), b), slot: v, attrs: a, slots: o, name: "ComboboxOption" }) } } }); var he = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(t => `${t}:not([tabindex='-1'])`).join(","); function de(t = document.body) { return t == null ? [] : Array.from(t.querySelectorAll(he)) } function Bt(t, o = 0) { return t === document.body ? !1 : k(o, { [0]() { return t.matches(he) }, [1]() { let a = t; for (; a !== null;) { if (a.matches(he)) return !0; a = a.parentElement } return !1 } }) } function X(t) { t == null || t.focus({ preventScroll: !0 }) } function L(t, o) { let a = Array.isArray(t) ? t.slice().sort((r, c) => { let s = r.compareDocumentPosition(c); return s & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : s & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0 }) : de(t), e = document.activeElement, l = (() => { if (o & 5) return 1; if (o & 10) return -1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), u = (() => { if (o & 1) return 0; if (o & 2) return Math.max(0, a.indexOf(e)) - 1; if (o & 4) return Math.max(0, a.indexOf(e)) + 1; if (o & 8) return a.length - 1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), d = o & 32 ? { preventScroll: !0 } : {}, p = 0, i = a.length, n; do { if (p >= i || p + i <= 0) return 0; let r = u + p; if (o & 16) r = (r + i) % i; else { if (r < 0) return 3; if (r >= i) return 1 } n = a[r], n == null || n.focus(d), p += l } while (n !== document.activeElement); return n.hasAttribute("tabindex") || n.setAttribute("tabindex", "0"), 2 } function xe(t, o) { for (let a of t) if (a.contains(o)) return !0; return !1 } function Ge(t, o = g(!0), a = g({})) { let e = g(typeof window != "undefined" ? document.activeElement : null), l = g(null); function u() { if (!o.value || t.value.size !== 1) return; let { initialFocus: p } = a.value, i = document.activeElement; if (p) { if (p === i) return } else if (xe(t.value, i)) return; if (e.value = i, p) X(p); else { let n = !1; for (let r of t.value) if (L(r, 1) === 2) { n = !0; break } n || console.warn("There are no focusable elements inside the <FocusTrap />") } l.value = document.activeElement } function d() { X(e.value), e.value = null, l.value = null } P(u), Ve(() => { o.value ? u() : d() }), j(d), M("keydown", p => { if (!!o.value && p.key === "Tab" && !!document.activeElement && t.value.size === 1) { p.preventDefault(); for (let i of t.value) if (L(i, (p.shiftKey ? 2 : 4) | 16) === 2) { l.value = document.activeElement; break } } }), M("focus", p => { if (!o.value || t.value.size !== 1) return; let i = l.value; if (!i) return; let n = p.target; n && n instanceof HTMLElement ? xe(t.value, n) ? (l.value = n, X(n)) : (p.preventDefault(), p.stopPropagation(), X(i)) : X(l.value) }, !0) } var Le = "body > *", J = new Set, U = new Map; function Ae(t) { t.setAttribute("aria-hidden", "true"), t.inert = !0 } function Fe(t) { let o = U.get(t); !o || (o["aria-hidden"] === null ? t.removeAttribute("aria-hidden") : t.setAttribute("aria-hidden", o["aria-hidden"]), t.inert = o.inert) } function Lt(t, o = g(!0)) { P(a => { if (!o.value || !t.value) return; let e = t.value; J.add(e); for (let l of U.keys()) l.contains(e) && (Fe(l), U.delete(l)); document.querySelectorAll(Le).forEach(l => { if (l instanceof HTMLElement) { for (let u of J) if (l.contains(u)) return; J.size === 1 && (U.set(l, { "aria-hidden": l.getAttribute("aria-hidden"), inert: l.inert }), Ae(l)) } }), a(() => { if (J.delete(e), J.size > 0) document.querySelectorAll(Le).forEach(l => { if (l instanceof HTMLElement && !U.has(l)) { for (let u of J) if (l.contains(u)) return; U.set(l, { "aria-hidden": l.getAttribute("aria-hidden"), inert: l.inert }), Ae(l) } }); else for (let l of U.keys()) Fe(l), U.delete(l) }) }) } var Ke = Symbol("StackContext"); function Ue() { return C(Ke, () => { }) } function At(t) { let o = Ue(); P(a => { let e = t == null ? void 0 : t.value; !e || (o(0, e), a(() => o(1, e))) }) } function qe(t) { let o = Ue(); function a(...e) { t == null || t(...e), o(...e) } D(Ke, a) } var ze = Symbol("ForcePortalRootContext"); function Ft() { return C(ze, !1) } var je = O({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(t, { slots: o, attrs: a }) { return D(ze, t.force), () => { let u = t, { force: e } = u, l = V(u, ["force"]); return I({ props: l, slot: {}, slots: o, attrs: a, name: "ForcePortalRoot" }) } } }); function jt() { let t = document.getElementById("headlessui-portal-root"); if (t) return t; let o = document.createElement("div"); return o.setAttribute("id", "headlessui-portal-root"), document.body.appendChild(o) } var $t = O({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(t, { slots: o, attrs: a }) { let e = Ft(), l = C(He, null), u = g(e === !0 || l === null ? jt() : l.resolveTarget()); P(() => { e || l !== null && (u.value = l.resolveTarget()) }); let d = g(null); return At(d), j(() => { var p; let i = document.getElementById("headlessui-portal-root"); !i || u.value === i && u.value.children.length <= 0 && ((p = u.value.parentElement) == null || p.removeChild(u.value)) }), qe(), () => { if (u.value === null) return null; let p = { ref: d }; return q(ht, { to: u.value }, I({ props: h(h({}, t), p), slot: {}, attrs: a, slots: o, name: "Portal" })) } } }), He = Symbol("PortalGroupContext"), Mt = O({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(t, { attrs: o, slots: a }) { let e = xt({ resolveTarget() { return t.target } }); return D(He, e), () => { let d = t, { target: l } = d, u = V(d, ["target"]); return I({ props: u, slot: {}, attrs: o, slots: a, name: "PortalGroup" }) } } }), We = Symbol("DescriptionContext"); function Vt() { let t = C(We, null); if (t === null) throw new Error("Missing parent"); return t } function ve({ slot: t = g({}), name: o = "Description", props: a = {} } = {}) { let e = g([]); function l(u) { return e.value.push(u), () => { let d = e.value.indexOf(u); d !== -1 && e.value.splice(d, 1) } } return D(We, { register: l, slot: t, name: o, props: a }), S(() => e.value.length > 0 ? e.value.join(" ") : void 0) } O({ name: "Description", props: { as: { type: [Object, String], default: "p" } }, setup(t, { attrs: o, slots: a }) { let e = Vt(), l = `headlessui-description-${E()}`; return B(() => j(e.register(l))), () => { let { name: u = "Description", slot: d = g({}), props: p = {} } = e, i = t, n = F(h({}, Object.entries(p).reduce((r, [c, s]) => Object.assign(r, { [c]: Me(s) }), {})), { id: l }); return I({ props: h(h({}, i), n), slot: d.value, attrs: o, slots: a, name: u }) } } }); var Qe = Symbol("DialogContext"); function Oe(t) { let o = C(Qe, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <Dialog /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, Oe), a } return o } var ue = "DC8F892D-2EBD-447C-A4C8-A03058436FF4", _t = O({ name: "Dialog", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, open: { type: [Boolean, String], default: ue }, initialFocus: { type: Object, default: null } }, emits: { close: t => !0 }, setup(t, { emit: o, attrs: a, slots: e }) { let l = g(new Set), u = G(), d = S(() => t.open === ue && u !== null ? k(u.value, { [0]: !0, [1]: !1 }) : t.open); if (!(t.open !== ue || u !== null)) throw new Error("You forgot to provide an `open` prop to the `Dialog`."); if (typeof d.value != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${d.value === ue ? void 0 : t.open}`); let p = S(() => t.open ? 0 : 1), i = S(() => u !== null ? u.value === 0 : p.value === 0), n = g(null), r = g(p.value === 0); Ve(() => { r.value = p.value === 0 }); let c = `headlessui-dialog-${E()}`, s = S(() => ({ initialFocus: t.initialFocus })); Ge(l, r, s), Lt(n, r), qe((x, w) => k(x, { [0]() { l.value.add(w) }, [1]() { l.value.delete(w) } })); let v = ve({ name: "DialogDescription", slot: S(() => ({ open: d.value })) }), b = g(null), f = { titleId: b, dialogState: p, setTitleId(x) { b.value !== x && (b.value = x) }, close() { o("close", !1) } }; D(Qe, f), M("mousedown", x => { let w = x.target; p.value === 0 && l.value.size === 1 && (xe(l.value, w) || (f.close(), R(() => w == null ? void 0 : w.focus()))) }), M("keydown", x => { x.key === "Escape" && p.value === 0 && (l.value.size > 1 || (x.preventDefault(), x.stopPropagation(), f.close())) }), P(x => { if (p.value !== 0) return; let w = document.documentElement.style.overflow, T = document.documentElement.style.paddingRight, A = window.innerWidth - document.documentElement.clientWidth; document.documentElement.style.overflow = "hidden", document.documentElement.style.paddingRight = `${A}px`, x(() => { document.documentElement.style.overflow = w, document.documentElement.style.paddingRight = T }) }), P(x => { if (p.value !== 0) return; let w = m(n); if (!w) return; let T = new IntersectionObserver(A => { for (let $ of A) $.boundingClientRect.x === 0 && $.boundingClientRect.y === 0 && $.boundingClientRect.width === 0 && $.boundingClientRect.height === 0 && f.close() }); T.observe(w), x(() => T.disconnect()) }); function y(x) { x.stopPropagation() } return () => { let x = F(h({}, a), { ref: n, id: c, role: "dialog", "aria-modal": p.value === 0 ? !0 : void 0, "aria-labelledby": b.value, "aria-describedby": v.value, onClick: y }), K = t, { open: w, initialFocus: T } = K, A = V(K, ["open", "initialFocus"]), $ = { open: p.value === 0 }; return q(je, { force: !0 }, () => q($t, () => q(Mt, { target: n.value }, () => q(je, { force: !1 }, () => I({ props: h(h({}, A), x), slot: $, attrs: a, slots: e, visible: i.value, features: 3, name: "Dialog" }))))) } } }), Nt = O({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" } }, setup(t, { attrs: o, slots: a }) { let e = Oe("DialogOverlay"), l = `headlessui-dialog-overlay-${E()}`; function u(d) { d.target === d.currentTarget && (d.preventDefault(), d.stopPropagation(), e.close()) } return () => I({ props: F(h({}, t), { id: l, "aria-hidden": !0, onClick: u }), slot: { open: e.dialogState.value === 0 }, attrs: o, slots: a, name: "DialogOverlay" }) } }); O({ name: "DialogTitle", props: { as: { type: [Object, String], default: "h2" } }, setup(t, { attrs: o, slots: a }) { let e = Oe("DialogTitle"), l = `headlessui-dialog-title-${E()}`; return B(() => { e.setTitleId(l), j(() => e.setTitleId(null)) }), () => I({ props: F(h({}, t), { id: l }), slot: { open: e.dialogState.value === 0 }, attrs: o, slots: a, name: "DialogTitle" }) } }); var Je = Symbol("DisclosureContext"); function Ie(t) { let o = C(Je, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <Disclosure /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, Ie), a } return o } var Ye = Symbol("DisclosurePanelContext"); function Gt() { return C(Ye, null) } O({ name: "Disclosure", props: { as: { type: [Object, String], default: "template" }, defaultOpen: { type: [Boolean], default: !1 } }, setup(t, { slots: o, attrs: a }) { let e = `headlessui-disclosure-button-${E()}`, l = `headlessui-disclosure-panel-${E()}`, u = g(t.defaultOpen ? 0 : 1), d = g(null), p = g(null), i = { buttonId: e, panelId: l, disclosureState: u, panel: d, button: p, toggleDisclosure() { u.value = k(u.value, { [0]: 1, [1]: 0 }) }, closeDisclosure() { u.value !== 1 && (u.value = 1) }, close(n) { i.closeDisclosure(); let r = (() => n ? n instanceof HTMLElement ? n : n.value instanceof HTMLElement ? m(n) : m(i.button) : m(i.button))(); r == null || r.focus() } }; return D(Je, i), Y(S(() => k(u.value, { [0]: 0, [1]: 1 }))), () => { let s = t, { defaultOpen: n } = s, r = V(s, ["defaultOpen"]), c = { open: u.value === 0, close: i.close }; return I({ props: r, slot: c, slots: o, attrs: a, name: "Disclosure" }) } } }); O({ name: "DisclosureButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 } }, setup(t, { attrs: o, slots: a }) { let e = Ie("DisclosureButton"), l = Gt(), u = l === null ? !1 : l === e.panelId, d = g(null); u || P(() => { e.button.value = d.value }); let p = Q(S(() => ({ as: t.as, type: o.type })), d); function i() { var c; t.disabled || (u ? (e.toggleDisclosure(), (c = m(e.button)) == null || c.focus()) : e.toggleDisclosure()) } function n(c) { var s; if (!t.disabled) if (u) switch (c.key) { case " ": case "Enter": c.preventDefault(), c.stopPropagation(), e.toggleDisclosure(), (s = m(e.button)) == null || s.focus(); break } else switch (c.key) { case " ": case "Enter": c.preventDefault(), c.stopPropagation(), e.toggleDisclosure(); break } } function r(c) { switch (c.key) { case " ": c.preventDefault(); break } } return () => { let c = { open: e.disclosureState.value === 0 }, s = u ? { ref: d, type: p.value, onClick: i, onKeydown: n } : { id: e.buttonId, ref: d, type: p.value, "aria-expanded": t.disabled ? void 0 : e.disclosureState.value === 0, "aria-controls": m(e.panel) ? e.panelId : void 0, disabled: t.disabled ? !0 : void 0, onClick: i, onKeydown: n, onKeyup: r }; return I({ props: h(h({}, t), s), slot: c, attrs: o, slots: a, name: "DisclosureButton" }) } } }); O({ name: "DisclosurePanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 } }, setup(t, { attrs: o, slots: a }) { let e = Ie("DisclosurePanel"); D(Ye, e.panelId); let l = G(), u = S(() => l !== null ? l.value === 0 : e.disclosureState.value === 0); return () => { let d = { open: e.disclosureState.value === 0, close: e.close }, p = { id: e.panelId, ref: e.panel }; return I({ props: h(h({}, t), p), slot: d, attrs: o, slots: a, features: 3, visible: u.value, name: "DisclosurePanel" }) } } }); O({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null } }, setup(t, { attrs: o, slots: a }) { let e = g(new Set), l = g(null), u = g(!0), d = S(() => ({ initialFocus: t.initialFocus })); return B(() => { !l.value || (e.value.add(l.value), Ge(e, u, d)) }), j(() => { u.value = !1 }), () => { let p = {}, i = { ref: l }, c = t, { initialFocus: n } = c, r = V(c, ["initialFocus"]); return I({ props: h(h({}, r), i), slot: p, attrs: o, slots: a, name: "FocusTrap" }) } } }); function Kt(t) { requestAnimationFrame(() => requestAnimationFrame(t)) } var Ze = Symbol("ListboxContext"); function ee(t) { let o = C(Ze, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <Listbox /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, ee), a } return o } O({ name: "Listbox", emits: { "update:modelValue": t => !0 }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: !1 }, horizontal: { type: [Boolean], default: !1 }, modelValue: { type: [Object, String, Number, Boolean] } }, setup(t, { slots: o, attrs: a, emit: e }) { let l = g(1), u = g(null), d = g(null), p = g(null), i = g([]), n = g(""), r = g(null), c = S(() => t.modelValue), s = { listboxState: l, value: c, orientation: S(() => t.horizontal ? "horizontal" : "vertical"), labelRef: u, buttonRef: d, optionsRef: p, disabled: S(() => t.disabled), options: i, searchQuery: n, activeOptionIndex: r, closeListbox() { t.disabled || l.value !== 1 && (l.value = 1, r.value = null) }, openListbox() { t.disabled || l.value !== 0 && (l.value = 0) }, goToOption(v, b) { if (t.disabled || l.value === 1) return; let f = Se(v === 4 ? { focus: 4, id: b } : { focus: v }, { resolveItems: () => i.value, resolveActiveIndex: () => r.value, resolveId: y => y.id, resolveDisabled: y => y.dataRef.disabled }); n.value === "" && r.value === f || (n.value = "", r.value = f) }, search(v) { if (t.disabled || l.value === 1) return; let b = n.value !== "" ? 0 : 1; n.value += v.toLowerCase(); let f = (r.value !== null ? i.value.slice(r.value + b).concat(i.value.slice(0, r.value + b)) : i.value).find(x => x.dataRef.textValue.startsWith(n.value) && !x.dataRef.disabled), y = f ? i.value.indexOf(f) : -1; y === -1 || y === r.value || (r.value = y) }, clearSearch() { t.disabled || l.value !== 1 && n.value !== "" && (n.value = "") }, registerOption(v, b) { var f, y; let x = Array.from((y = (f = p.value) == null ? void 0 : f.querySelectorAll('[id^="headlessui-listbox-option-"]')) != null ? y : []).reduce((w, T, A) => Object.assign(w, { [T.id]: A }), {}); i.value = [...i.value, { id: v, dataRef: b }].sort((w, T) => x[w.id] - x[T.id]) }, unregisterOption(v) { let b = i.value.slice(), f = r.value !== null ? b[r.value] : null, y = b.findIndex(x => x.id === v); y !== -1 && b.splice(y, 1), i.value = b, r.value = (() => y === r.value || f === null ? null : b.indexOf(f))() }, select(v) { t.disabled || e("update:modelValue", v) } }; return M("mousedown", v => { var b, f, y; let x = v.target, w = document.activeElement; l.value === 0 && (((b = m(d)) == null ? void 0 : b.contains(x)) || (((f = m(p)) == null ? void 0 : f.contains(x)) || s.closeListbox(), !(w !== document.body && (w == null ? void 0 : w.contains(x))) && (v.defaultPrevented || (y = m(d)) == null || y.focus({ preventScroll: !0 })))) }), D(Ze, s), Y(S(() => k(l.value, { [0]: 0, [1]: 1 }))), () => { let v = { open: l.value === 0, disabled: t.disabled }; return I({ props: z(t, ["modelValue", "onUpdate:modelValue", "disabled", "horizontal"]), slot: v, slots: o, attrs: a, name: "Listbox" }) } } }); O({ name: "ListboxLabel", props: { as: { type: [Object, String], default: "label" } }, setup(t, { attrs: o, slots: a }) { let e = ee("ListboxLabel"), l = `headlessui-listbox-label-${E()}`; function u() { var d; (d = m(e.buttonRef)) == null || d.focus({ preventScroll: !0 }) } return () => { let d = { open: e.listboxState.value === 0, disabled: e.disabled.value }, p = { id: l, ref: e.labelRef, onClick: u }; return I({ props: h(h({}, t), p), slot: d, attrs: o, slots: a, name: "ListboxLabel" }) } } }); O({ name: "ListboxButton", props: { as: { type: [Object, String], default: "button" } }, setup(t, { attrs: o, slots: a }) { let e = ee("ListboxButton"), l = `headlessui-listbox-button-${E()}`; function u(n) { switch (n.key) { case " ": case "Enter": case "ArrowDown": n.preventDefault(), e.openListbox(), R(() => { var r; (r = m(e.optionsRef)) == null || r.focus({ preventScroll: !0 }), e.value.value || e.goToOption(0) }); break; case "ArrowUp": n.preventDefault(), e.openListbox(), R(() => { var r; (r = m(e.optionsRef)) == null || r.focus({ preventScroll: !0 }), e.value.value || e.goToOption(3) }); break } } function d(n) { switch (n.key) { case " ": n.preventDefault(); break } } function p(n) { e.disabled.value || (e.listboxState.value === 0 ? (e.closeListbox(), R(() => { var r; return (r = m(e.buttonRef)) == null ? void 0 : r.focus({ preventScroll: !0 }) })) : (n.preventDefault(), e.openListbox(), Kt(() => { var r; return (r = m(e.optionsRef)) == null ? void 0 : r.focus({ preventScroll: !0 }) }))) } let i = Q(S(() => ({ as: t.as, type: o.type })), e.buttonRef); return () => { var n, r; let c = { open: e.listboxState.value === 0, disabled: e.disabled.value }, s = { ref: e.buttonRef, id: l, type: i.value, "aria-haspopup": !0, "aria-controls": (n = m(e.optionsRef)) == null ? void 0 : n.id, "aria-expanded": e.disabled.value ? void 0 : e.listboxState.value === 0, "aria-labelledby": e.labelRef.value ? [(r = m(e.labelRef)) == null ? void 0 : r.id, l].join(" ") : void 0, disabled: e.disabled.value === !0 ? !0 : void 0, onKeydown: u, onKeyup: d, onClick: p }; return I({ props: h(h({}, t), s), slot: c, attrs: o, slots: a, name: "ListboxButton" }) } } }); O({ name: "ListboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 } }, setup(t, { attrs: o, slots: a }) { let e = ee("ListboxOptions"), l = `headlessui-listbox-options-${E()}`, u = g(null); function d(n) { switch (u.value && clearTimeout(u.value), n.key) { case " ": if (e.searchQuery.value !== "") return n.preventDefault(), n.stopPropagation(), e.search(n.key); case "Enter": if (n.preventDefault(), n.stopPropagation(), e.activeOptionIndex.value !== null) { let { dataRef: r } = e.options.value[e.activeOptionIndex.value]; e.select(r.value) } e.closeListbox(), R(() => { var r; return (r = m(e.buttonRef)) == null ? void 0 : r.focus({ preventScroll: !0 }) }); break; case k(e.orientation.value, { vertical: "ArrowDown", horizontal: "ArrowRight" }): return n.preventDefault(), n.stopPropagation(), e.goToOption(2); case k(e.orientation.value, { vertical: "ArrowUp", horizontal: "ArrowLeft" }): return n.preventDefault(), n.stopPropagation(), e.goToOption(1); case "Home": case "PageUp": return n.preventDefault(), n.stopPropagation(), e.goToOption(0); case "End": case "PageDown": return n.preventDefault(), n.stopPropagation(), e.goToOption(3); case "Escape": n.preventDefault(), n.stopPropagation(), e.closeListbox(), R(() => { var r; return (r = m(e.buttonRef)) == null ? void 0 : r.focus({ preventScroll: !0 }) }); break; case "Tab": n.preventDefault(), n.stopPropagation(); break; default: n.key.length === 1 && (e.search(n.key), u.value = setTimeout(() => e.clearSearch(), 350)); break } } let p = G(), i = S(() => p !== null ? p.value === 0 : e.listboxState.value === 0); return () => { var n, r, c, s; let v = { open: e.listboxState.value === 0 }, b = { "aria-activedescendant": e.activeOptionIndex.value === null || (n = e.options.value[e.activeOptionIndex.value]) == null ? void 0 : n.id, "aria-labelledby": (s = (r = m(e.labelRef)) == null ? void 0 : r.id) != null ? s : (c = m(e.buttonRef)) == null ? void 0 : c.id, "aria-orientation": e.orientation.value, id: l, onKeydown: d, role: "listbox", tabIndex: 0, ref: e.optionsRef }; return I({ props: h(h({}, t), b), slot: v, attrs: o, slots: a, features: 3, visible: i.value, name: "ListboxOptions" }) } } }); O({ name: "ListboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 } }, setup(t, { slots: o, attrs: a }) { let e = ee("ListboxOption"), l = `headlessui-listbox-option-${E()}`, u = S(() => e.activeOptionIndex.value !== null ? e.options.value[e.activeOptionIndex.value].id === l : !1), d = S(() => N(e.value.value) === N(t.value)), p = g({ disabled: t.disabled, value: t.value, textValue: "" }); B(() => { var s, v; let b = (v = (s = document.getElementById(l)) == null ? void 0 : s.textContent) == null ? void 0 : v.toLowerCase().trim(); b !== void 0 && (p.value.textValue = b) }), B(() => e.registerOption(l, p)), j(() => e.unregisterOption(l)), B(() => { pe([e.listboxState, d], () => { var s, v; e.listboxState.value === 0 && (!d.value || (e.goToOption(4, l), (v = (s = document.getElementById(l)) == null ? void 0 : s.focus) == null || v.call(s))) }, { immediate: !0 }) }), P(() => { e.listboxState.value === 0 && (!u.value || R(() => { var s, v; return (v = (s = document.getElementById(l)) == null ? void 0 : s.scrollIntoView) == null ? void 0 : v.call(s, { block: "nearest" }) })) }); function i(s) { if (t.disabled) return s.preventDefault(); e.select(t.value), e.closeListbox(), R(() => { var v; return (v = m(e.buttonRef)) == null ? void 0 : v.focus({ preventScroll: !0 }) }) } function n() { if (t.disabled) return e.goToOption(5); e.goToOption(4, l) } function r() { t.disabled || u.value || e.goToOption(4, l) } function c() { t.disabled || !u.value || e.goToOption(5) } return () => { let { disabled: s } = t, v = { active: u.value, selected: d.value, disabled: s }, b = { id: l, role: "option", tabIndex: s === !0 ? void 0 : -1, "aria-disabled": s === !0 ? !0 : void 0, "aria-selected": d.value === !0 ? d.value : void 0, disabled: void 0, onClick: i, onFocus: n, onPointermove: r, onMousemove: r, onPointerleave: c, onMouseleave: c }; return I({ props: h(h({}, t), b), slot: v, attrs: a, slots: o, name: "ListboxOption" }) } } }); function Ut(t) { requestAnimationFrame(() => requestAnimationFrame(t)) } var Xe = Symbol("MenuContext"); function ce(t) { let o = C(Xe, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <Menu /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, ce), a } return o } O({ name: "Menu", props: { as: { type: [Object, String], default: "template" } }, setup(t, { slots: o, attrs: a }) { let e = g(1), l = g(null), u = g(null), d = g([]), p = g(""), i = g(null), n = { menuState: e, buttonRef: l, itemsRef: u, items: d, searchQuery: p, activeItemIndex: i, closeMenu: () => { e.value = 1, i.value = null }, openMenu: () => e.value = 0, goToItem(r, c) { let s = Se(r === 4 ? { focus: 4, id: c } : { focus: r }, { resolveItems: () => d.value, resolveActiveIndex: () => i.value, resolveId: v => v.id, resolveDisabled: v => v.dataRef.disabled }); p.value === "" && i.value === s || (p.value = "", i.value = s) }, search(r) { let c = p.value !== "" ? 0 : 1; p.value += r.toLowerCase(); let s = (i.value !== null ? d.value.slice(i.value + c).concat(d.value.slice(0, i.value + c)) : d.value).find(b => b.dataRef.textValue.startsWith(p.value) && !b.dataRef.disabled), v = s ? d.value.indexOf(s) : -1; v === -1 || v === i.value || (i.value = v) }, clearSearch() { p.value = "" }, registerItem(r, c) { var s, v; let b = Array.from((v = (s = u.value) == null ? void 0 : s.querySelectorAll('[id^="headlessui-menu-item-"]')) != null ? v : []).reduce((f, y, x) => Object.assign(f, { [y.id]: x }), {}); d.value = [...d.value, { id: r, dataRef: c }].sort((f, y) => b[f.id] - b[y.id]) }, unregisterItem(r) { let c = d.value.slice(), s = i.value !== null ? c[i.value] : null, v = c.findIndex(b => b.id === r); v !== -1 && c.splice(v, 1), d.value = c, i.value = (() => v === i.value || s === null ? null : c.indexOf(s))() } }; return M("mousedown", r => { var c, s, v; let b = r.target, f = document.activeElement; e.value === 0 && (((c = m(l)) == null ? void 0 : c.contains(b)) || (((s = m(u)) == null ? void 0 : s.contains(b)) || n.closeMenu(), !(f !== document.body && (f == null ? void 0 : f.contains(b))) && (r.defaultPrevented || (v = m(l)) == null || v.focus({ preventScroll: !0 })))) }), D(Xe, n), Y(S(() => k(e.value, { [0]: 0, [1]: 1 }))), () => { let r = { open: e.value === 0 }; return I({ props: t, slot: r, slots: o, attrs: a, name: "Menu" }) } } }); O({ name: "MenuButton", props: { disabled: { type: Boolean, default: !1 }, as: { type: [Object, String], default: "button" } }, setup(t, { attrs: o, slots: a }) { let e = ce("MenuButton"), l = `headlessui-menu-button-${E()}`; function u(n) { switch (n.key) { case " ": case "Enter": case "ArrowDown": n.preventDefault(), n.stopPropagation(), e.openMenu(), R(() => { var r; (r = m(e.itemsRef)) == null || r.focus({ preventScroll: !0 }), e.goToItem(0) }); break; case "ArrowUp": n.preventDefault(), n.stopPropagation(), e.openMenu(), R(() => { var r; (r = m(e.itemsRef)) == null || r.focus({ preventScroll: !0 }), e.goToItem(3) }); break } } function d(n) { switch (n.key) { case " ": n.preventDefault(); break } } function p(n) { t.disabled || (e.menuState.value === 0 ? (e.closeMenu(), R(() => { var r; return (r = m(e.buttonRef)) == null ? void 0 : r.focus({ preventScroll: !0 }) })) : (n.preventDefault(), n.stopPropagation(), e.openMenu(), Ut(() => { var r; return (r = m(e.itemsRef)) == null ? void 0 : r.focus({ preventScroll: !0 }) }))) } let i = Q(S(() => ({ as: t.as, type: o.type })), e.buttonRef); return () => { var n; let r = { open: e.menuState.value === 0 }, c = { ref: e.buttonRef, id: l, type: i.value, "aria-haspopup": !0, "aria-controls": (n = m(e.itemsRef)) == null ? void 0 : n.id, "aria-expanded": t.disabled ? void 0 : e.menuState.value === 0, onKeydown: u, onKeyup: d, onClick: p }; return I({ props: h(h({}, t), c), slot: r, attrs: o, slots: a, name: "MenuButton" }) } } }); O({ name: "MenuItems", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 } }, setup(t, { attrs: o, slots: a }) { let e = ce("MenuItems"), l = `headlessui-menu-items-${E()}`, u = g(null); we({ container: S(() => m(e.itemsRef)), enabled: S(() => e.menuState.value === 0), accept(r) { return r.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : r.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT }, walk(r) { r.setAttribute("role", "none") } }); function d(r) { var c; switch (u.value && clearTimeout(u.value), r.key) { case " ": if (e.searchQuery.value !== "") return r.preventDefault(), r.stopPropagation(), e.search(r.key); case "Enter": if (r.preventDefault(), r.stopPropagation(), e.activeItemIndex.value !== null) { let { id: s } = e.items.value[e.activeItemIndex.value]; (c = document.getElementById(s)) == null || c.click() } e.closeMenu(), R(() => { var s; return (s = m(e.buttonRef)) == null ? void 0 : s.focus({ preventScroll: !0 }) }); break; case "ArrowDown": return r.preventDefault(), r.stopPropagation(), e.goToItem(2); case "ArrowUp": return r.preventDefault(), r.stopPropagation(), e.goToItem(1); case "Home": case "PageUp": return r.preventDefault(), r.stopPropagation(), e.goToItem(0); case "End": case "PageDown": return r.preventDefault(), r.stopPropagation(), e.goToItem(3); case "Escape": r.preventDefault(), r.stopPropagation(), e.closeMenu(), R(() => { var s; return (s = m(e.buttonRef)) == null ? void 0 : s.focus({ preventScroll: !0 }) }); break; case "Tab": r.preventDefault(), r.stopPropagation(); break; default: r.key.length === 1 && (e.search(r.key), u.value = setTimeout(() => e.clearSearch(), 350)); break } } function p(r) { switch (r.key) { case " ": r.preventDefault(); break } } let i = G(), n = S(() => i !== null ? i.value === 0 : e.menuState.value === 0); return () => { var r, c; let s = { open: e.menuState.value === 0 }, v = { "aria-activedescendant": e.activeItemIndex.value === null || (r = e.items.value[e.activeItemIndex.value]) == null ? void 0 : r.id, "aria-labelledby": (c = m(e.buttonRef)) == null ? void 0 : c.id, id: l, onKeydown: d, onKeyup: p, role: "menu", tabIndex: 0, ref: e.itemsRef }; return I({ props: h(h({}, t), v), slot: s, attrs: o, slots: a, features: 3, visible: n.value, name: "MenuItems" }) } } }); O({ name: "MenuItem", props: { as: { type: [Object, String], default: "template" }, disabled: { type: Boolean, default: !1 } }, setup(t, { slots: o, attrs: a }) { let e = ce("MenuItem"), l = `headlessui-menu-item-${E()}`, u = S(() => e.activeItemIndex.value !== null ? e.items.value[e.activeItemIndex.value].id === l : !1), d = g({ disabled: t.disabled, textValue: "" }); B(() => { var c, s; let v = (s = (c = document.getElementById(l)) == null ? void 0 : c.textContent) == null ? void 0 : s.toLowerCase().trim(); v !== void 0 && (d.value.textValue = v) }), B(() => e.registerItem(l, d)), j(() => e.unregisterItem(l)), P(() => { e.menuState.value === 0 && (!u.value || R(() => { var c, s; return (s = (c = document.getElementById(l)) == null ? void 0 : c.scrollIntoView) == null ? void 0 : s.call(c, { block: "nearest" }) })) }); function p(c) { if (t.disabled) return c.preventDefault(); e.closeMenu(), R(() => { var s; return (s = m(e.buttonRef)) == null ? void 0 : s.focus({ preventScroll: !0 }) }) } function i() { if (t.disabled) return e.goToItem(5); e.goToItem(4, l) } function n() { t.disabled || u.value || e.goToItem(4, l) } function r() { t.disabled || !u.value || e.goToItem(5) } return () => { let { disabled: c } = t, s = { active: u.value, disabled: c }; return I({ props: F(h({}, t), { id: l, role: "menuitem", tabIndex: c === !0 ? void 0 : -1, "aria-disabled": c === !0 ? !0 : void 0, onClick: p, onFocus: i, onPointermove: n, onMousemove: n, onPointerleave: r, onMouseleave: r }), slot: s, attrs: a, slots: o, name: "MenuItem" }) } } }); var et = Symbol("PopoverContext"); function fe(t) { let o = C(et, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <${zt.name} /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, fe), a } return o } var tt = Symbol("PopoverGroupContext"); function lt() { return C(tt, null) } var ot = Symbol("PopoverPanelContext"); function qt() { return C(ot, null) } var zt = O({ name: "Popover", props: { as: { type: [Object, String], default: "div" } }, setup(t, { slots: o, attrs: a }) { let e = `headlessui-popover-button-${E()}`, l = `headlessui-popover-panel-${E()}`, u = g(1), d = g(null), p = g(null), i = { popoverState: u, buttonId: e, panelId: l, panel: p, button: d, togglePopover() { u.value = k(u.value, { [0]: 1, [1]: 0 }) }, closePopover() { u.value !== 1 && (u.value = 1) }, close(v) { i.closePopover(); let b = (() => v ? v instanceof HTMLElement ? v : v.value instanceof HTMLElement ? m(v) : m(i.button) : m(i.button))(); b == null || b.focus() } }; D(et, i), Y(S(() => k(u.value, { [0]: 0, [1]: 1 }))); let n = { buttonId: e, panelId: l, close() { i.closePopover() } }, r = lt(), c = r == null ? void 0 : r.registerPopover; function s() { var v, b, f; return (f = r == null ? void 0 : r.isFocusWithinPopoverGroup()) != null ? f : ((v = m(d)) == null ? void 0 : v.contains(document.activeElement)) || ((b = m(p)) == null ? void 0 : b.contains(document.activeElement)) } return P(() => c == null ? void 0 : c(n)), M("focus", () => { u.value === 0 && (s() || !d || !p || i.closePopover()) }, !0), M("mousedown", v => { var b, f, y; let x = v.target; u.value === 0 && (((b = m(d)) == null ? void 0 : b.contains(x)) || ((f = m(p)) == null ? void 0 : f.contains(x)) || (i.closePopover(), Bt(x, 1) || (v.preventDefault(), (y = m(d)) == null || y.focus()))) }), () => { let v = { open: u.value === 0, close: i.close }; return I({ props: t, slot: v, slots: o, attrs: a, name: "Popover" }) } } }); O({ name: "PopoverButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 } }, setup(t, { attrs: o, slots: a }) { let e = fe("PopoverButton"), l = lt(), u = l == null ? void 0 : l.closeOthers, d = qt(), p = d === null ? !1 : d === e.panelId, i = g(null), n = g(typeof window == "undefined" ? null : document.activeElement); M("focus", () => { n.value = i.value, i.value = document.activeElement }, !0); let r = g(null); p || P(() => { e.button.value = r.value }); let c = Q(S(() => ({ as: t.as, type: o.type })), r); function s(f) { var y, x, w, T; if (p) { if (e.popoverState.value === 1) return; switch (f.key) { case " ": case "Enter": f.preventDefault(), f.stopPropagation(), e.closePopover(), (y = m(e.button)) == null || y.focus(); break } } else switch (f.key) { case " ": case "Enter": f.preventDefault(), f.stopPropagation(), e.popoverState.value === 1 && (u == null || u(e.buttonId)), e.togglePopover(); break; case "Escape": if (e.popoverState.value !== 0) return u == null ? void 0 : u(e.buttonId); if (!m(e.button) || !((x = m(e.button)) == null ? void 0 : x.contains(document.activeElement))) return; f.preventDefault(), f.stopPropagation(), e.closePopover(); break; case "Tab": if (e.popoverState.value !== 0 || !e.panel || !e.button) return; if (f.shiftKey) { if (!n.value || ((w = m(e.button)) == null ? void 0 : w.contains(n.value)) || ((T = m(e.panel)) == null ? void 0 : T.contains(n.value))) return; let A = de(), $ = A.indexOf(n.value); if (A.indexOf(m(e.button)) > $) return; f.preventDefault(), f.stopPropagation(), L(m(e.panel), 8) } else f.preventDefault(), f.stopPropagation(), L(m(e.panel), 1); break } } function v(f) { var y, x; if (!p && (f.key === " " && f.preventDefault(), e.popoverState.value === 0 && !!e.panel && !!e.button)) switch (f.key) { case "Tab": if (!n.value || ((y = m(e.button)) == null ? void 0 : y.contains(n.value)) || ((x = m(e.panel)) == null ? void 0 : x.contains(n.value))) return; let w = de(), T = w.indexOf(n.value); if (w.indexOf(m(e.button)) > T) return; f.preventDefault(), f.stopPropagation(), L(m(e.panel), 8); break } } function b() { var f, y; t.disabled || (p ? (e.closePopover(), (f = m(e.button)) == null || f.focus()) : (e.popoverState.value === 1 && (u == null || u(e.buttonId)), (y = m(e.button)) == null || y.focus(), e.togglePopover())) } return () => { let f = { open: e.popoverState.value === 0 }, y = p ? { ref: r, type: c.value, onKeydown: s, onClick: b } : { ref: r, id: e.buttonId, type: c.value, "aria-expanded": t.disabled ? void 0 : e.popoverState.value === 0, "aria-controls": m(e.panel) ? e.panelId : void 0, disabled: t.disabled ? !0 : void 0, onKeydown: s, onKeyup: v, onClick: b }; return I({ props: h(h({}, t), y), slot: f, attrs: o, slots: a, name: "PopoverButton" }) } } }); O({ name: "PopoverOverlay", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 } }, setup(t, { attrs: o, slots: a }) { let e = fe("PopoverOverlay"), l = `headlessui-popover-overlay-${E()}`, u = G(), d = S(() => u !== null ? u.value === 0 : e.popoverState.value === 0); function p() { e.closePopover() } return () => { let i = { open: e.popoverState.value === 0 }; return I({ props: F(h({}, t), { id: l, "aria-hidden": !0, onClick: p }), slot: i, attrs: o, slots: a, features: 3, visible: d.value, name: "PopoverOverlay" }) } } }); O({ name: "PopoverPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, focus: { type: Boolean, default: !1 } }, setup(t, { attrs: o, slots: a }) { let { focus: e } = t, l = fe("PopoverPanel"); D(ot, l.panelId), j(() => { l.panel.value = null }), P(() => { var i; if (!e || l.popoverState.value !== 0 || !l.panel) return; let n = document.activeElement; ((i = m(l.panel)) == null ? void 0 : i.contains(n)) || L(m(l.panel), 1) }), M("keydown", i => { var n, r; if (l.popoverState.value !== 0 || !m(l.panel) || i.key !== "Tab" || !document.activeElement || !((n = m(l.panel)) == null ? void 0 : n.contains(document.activeElement))) return; i.preventDefault(); let c = L(m(l.panel), i.shiftKey ? 2 : 4); if (c === 3) return (r = m(l.button)) == null ? void 0 : r.focus(); if (c === 1) { if (!m(l.button)) return; let s = de(), v = s.indexOf(m(l.button)), b = s.splice(v + 1).filter(f => { var y; return !((y = m(l.panel)) == null ? void 0 : y.contains(f)) }); L(b, 1) === 0 && L(document.body, 1) } }), M("focus", () => { var i; !e || l.popoverState.value === 0 && (!m(l.panel) || ((i = m(l.panel)) == null ? void 0 : i.contains(document.activeElement)) || l.closePopover()) }, !0); let u = G(), d = S(() => u !== null ? u.value === 0 : l.popoverState.value === 0); function p(i) { var n, r; switch (i.key) { case "Escape": if (l.popoverState.value !== 0 || !m(l.panel) || !((n = m(l.panel)) == null ? void 0 : n.contains(document.activeElement))) return; i.preventDefault(), i.stopPropagation(), l.closePopover(), (r = m(l.button)) == null || r.focus(); break } } return () => { let i = { open: l.popoverState.value === 0, close: l.close }, n = { ref: l.panel, id: l.panelId, onKeydown: p }; return I({ props: h(h({}, t), n), slot: i, attrs: o, slots: a, features: 3, visible: d.value, name: "PopoverPanel" }) } } }); O({ name: "PopoverGroup", props: { as: { type: [Object, String], default: "div" } }, setup(t, { attrs: o, slots: a }) { let e = g(null), l = g([]); function u(n) { let r = l.value.indexOf(n); r !== -1 && l.value.splice(r, 1) } function d(n) { return l.value.push(n), () => { u(n) } } function p() { var n; let r = document.activeElement; return ((n = m(e)) == null ? void 0 : n.contains(r)) ? !0 : l.value.some(c => { var s, v; return ((s = document.getElementById(c.buttonId)) == null ? void 0 : s.contains(r)) || ((v = document.getElementById(c.panelId)) == null ? void 0 : v.contains(r)) }) } function i(n) { for (let r of l.value) r.buttonId !== n && r.close() } return D(tt, { registerPopover: d, unregisterPopover: u, isFocusWithinPopoverGroup: p, closeOthers: i }), () => I({ props: F(h({}, t), { ref: e }), slot: {}, attrs: o, slots: a, name: "PopoverGroup" }) } }); var at = Symbol("LabelContext"); function nt() { let t = C(at, null); if (t === null) { let o = new Error("You used a <Label /> component, but it is not inside a parent."); throw Error.captureStackTrace && Error.captureStackTrace(o, nt), o } return t } function Ee({ slot: t = {}, name: o = "Label", props: a = {} } = {}) { let e = g([]); function l(u) { return e.value.push(u), () => { let d = e.value.indexOf(u); d !== -1 && e.value.splice(d, 1) } } return D(at, { register: l, slot: t, name: o, props: a }), S(() => e.value.length > 0 ? e.value.join(" ") : void 0) } O({ name: "Label", props: { as: { type: [Object, String], default: "label" }, passive: { type: [Boolean], default: !1 } }, setup(t, { slots: o, attrs: a }) { let e = nt(), l = `headlessui-label-${E()}`; return B(() => j(e.register(l))), () => { let { name: u = "Label", slot: d = {}, props: p = {} } = e, s = t, { passive: i } = s, n = V(s, ["passive"]), r = F(h({}, Object.entries(p).reduce((v, [b, f]) => Object.assign(v, { [b]: Me(f) }), {})), { id: l }), c = h(h({}, n), r); return i && delete c.onClick, I({ props: c, slot: d, attrs: a, slots: o, name: u }) } } }); var rt = Symbol("RadioGroupContext"); function ut(t) { let o = C(rt, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <RadioGroup /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, ut), a } return o } O({ name: "RadioGroup", emits: { "update:modelValue": t => !0 }, props: { as: { type: [Object, String], default: "div" }, disabled: { type: [Boolean], default: !1 }, modelValue: { type: [Object, String, Number, Boolean] } }, setup(t, { emit: o, attrs: a, slots: e }) { let l = g(null), u = g([]), d = Ee({ name: "RadioGroupLabel" }), p = ve({ name: "RadioGroupDescription" }), i = S(() => t.modelValue), n = { options: u, value: i, disabled: S(() => t.disabled), firstOption: S(() => u.value.find(s => !s.propsRef.disabled)), containsCheckedOption: S(() => u.value.some(s => N(s.propsRef.value) === N(t.modelValue))), change(s) { var v; if (t.disabled || i.value === s) return !1; let b = (v = u.value.find(f => N(f.propsRef.value) === N(s))) == null ? void 0 : v.propsRef; return (b == null ? void 0 : b.disabled) ? !1 : (o("update:modelValue", s), !0) }, registerOption(s) { var v; let b = Array.from((v = l.value) == null ? void 0 : v.querySelectorAll('[id^="headlessui-radiogroup-option-"]')).reduce((f, y, x) => Object.assign(f, { [y.id]: x }), {}); u.value.push(s), u.value.sort((f, y) => b[f.id] - b[y.id]) }, unregisterOption(s) { let v = u.value.findIndex(b => b.id === s); v !== -1 && u.value.splice(v, 1) } }; D(rt, n), we({ container: S(() => m(l)), accept(s) { return s.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : s.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT }, walk(s) { s.setAttribute("role", "none") } }); function r(s) { if (!l.value || !l.value.contains(s.target)) return; let v = u.value.filter(b => b.propsRef.disabled === !1).map(b => b.element); switch (s.key) { case "ArrowLeft": case "ArrowUp": if (s.preventDefault(), s.stopPropagation(), L(v, 18) === 2) { let b = u.value.find(f => f.element === document.activeElement); b && n.change(b.propsRef.value) } break; case "ArrowRight": case "ArrowDown": if (s.preventDefault(), s.stopPropagation(), L(v, 20) === 2) { let b = u.value.find(f => f.element === document.activeElement); b && n.change(b.propsRef.value) } break; case " ": { s.preventDefault(), s.stopPropagation(); let b = u.value.find(f => f.element === document.activeElement); b && n.change(b.propsRef.value) } break } } let c = `headlessui-radiogroup-${E()}`; return () => { let y = t, { modelValue: s, disabled: v } = y, b = V(y, ["modelValue", "disabled"]), f = { ref: l, id: c, role: "radiogroup", "aria-labelledby": d.value, "aria-describedby": p.value, onKeydown: r }; return I({ props: h(h({}, b), f), slot: {}, attrs: a, slots: e, name: "RadioGroup" }) } } }); O({ name: "RadioGroupOption", props: { as: { type: [Object, String], default: "div" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 } }, setup(t, { attrs: o, slots: a }) { let e = ut("RadioGroupOption"), l = `headlessui-radiogroup-option-${E()}`, u = Ee({ name: "RadioGroupLabel" }), d = ve({ name: "RadioGroupDescription" }), p = g(null), i = S(() => ({ value: t.value, disabled: t.disabled })), n = g(1); B(() => e.registerOption({ id: l, element: p, propsRef: i })), j(() => e.unregisterOption(l)); let r = S(() => { var x; return ((x = e.firstOption.value) == null ? void 0 : x.id) === l }), c = S(() => e.disabled.value || t.disabled), s = S(() => N(e.value.value) === N(t.value)), v = S(() => c.value ? -1 : s.value || !e.containsCheckedOption.value && r.value ? 0 : -1); function b() { var x; !e.change(t.value) || (n.value |= 2, (x = p.value) == null || x.focus()) } function f() { n.value |= 2 } function y() { n.value &= -3 } return () => { let x = z(t, ["value", "disabled"]), w = { checked: s.value, disabled: c.value, active: Boolean(n.value & 2) }, T = { id: l, ref: p, role: "radio", "aria-checked": s.value ? "true" : "false", "aria-labelledby": u.value, "aria-describedby": d.value, "aria-disabled": c.value ? !0 : void 0, tabIndex: v.value, onClick: c.value ? void 0 : b, onFocus: c.value ? void 0 : f, onBlur: c.value ? void 0 : y }; return I({ props: h(h({}, x), T), slot: w, attrs: o, slots: a, name: "RadioGroupOption" }) } } }); var it = Symbol("GroupContext"); O({ name: "SwitchGroup", props: { as: { type: [Object, String], default: "template" } }, setup(t, { slots: o, attrs: a }) { let e = g(null), l = Ee({ name: "SwitchLabel", props: { onClick() { !e.value || (e.value.click(), e.value.focus({ preventScroll: !0 })) } } }), u = ve({ name: "SwitchDescription" }); return D(it, { switchRef: e, labelledby: l, describedby: u }), () => I({ props: t, slot: {}, slots: o, attrs: a, name: "SwitchGroup" }) } }); O({ name: "Switch", emits: { "update:modelValue": t => !0 }, props: { as: { type: [Object, String], default: "button" }, modelValue: { type: Boolean, default: !1 } }, setup(t, { emit: o, attrs: a, slots: e }) { let l = C(it, null), u = `headlessui-switch-${E()}`; function d() { o("update:modelValue", !t.modelValue) } let p = g(null), i = l === null ? p : l.switchRef, n = Q(S(() => ({ as: t.as, type: a.type })), i); function r(v) { v.preventDefault(), d() } function c(v) { v.key !== "Tab" && v.preventDefault(), v.key === " " && d() } function s(v) { v.preventDefault() } return () => { let v = { checked: t.modelValue }, b = { id: u, ref: i, role: "switch", type: n.value, tabIndex: 0, "aria-checked": t.modelValue, "aria-labelledby": l == null ? void 0 : l.labelledby.value, "aria-describedby": l == null ? void 0 : l.describedby.value, onClick: r, onKeyup: c, onKeypress: s }; return I({ props: h(h({}, t), b), slot: v, attrs: a, slots: e, name: "Switch" }) } } }); var st = Symbol("TabsContext"); function te(t) { let o = C(st, null); if (o === null) { let a = new Error(`<${t} /> is missing a parent <TabGroup /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(a, te), a } return o } O({ name: "TabGroup", emits: { change: t => !0 }, props: { as: { type: [Object, String], default: "template" }, selectedIndex: { type: [Number], default: null }, defaultIndex: { type: [Number], default: 0 }, vertical: { type: [Boolean], default: !1 }, manual: { type: [Boolean], default: !1 } }, setup(t, { slots: o, attrs: a, emit: e }) { let l = g(null), u = g([]), d = g([]), p = { selectedIndex: l, orientation: S(() => t.vertical ? "vertical" : "horizontal"), activation: S(() => t.manual ? "manual" : "auto"), tabs: u, panels: d, setSelectedIndex(i) { l.value !== i && (l.value = i, e("change", i)) }, registerTab(i) { u.value.includes(i) || u.value.push(i) }, unregisterTab(i) { let n = u.value.indexOf(i); n !== -1 && u.value.splice(n, 1) }, registerPanel(i) { d.value.includes(i) || d.value.push(i) }, unregisterPanel(i) { let n = d.value.indexOf(i); n !== -1 && d.value.splice(n, 1) } }; return D(st, p), P(() => { var i; if (p.tabs.value.length <= 0 || t.selectedIndex === null && l.value !== null) return; let n = p.tabs.value.map(s => m(s)).filter(Boolean), r = n.filter(s => !s.hasAttribute("disabled")), c = (i = t.selectedIndex) != null ? i : t.defaultIndex; if (c < 0) l.value = n.indexOf(r[0]); else if (c > p.tabs.value.length) l.value = n.indexOf(r[r.length - 1]); else { let s = n.slice(0, c), v = [...n.slice(c), ...s].find(b => r.includes(b)); if (!v) return; l.value = n.indexOf(v) } }), () => { let i = { selectedIndex: l.value }; return I({ props: z(t, ["selectedIndex", "defaultIndex", "manual", "vertical", "onChange"]), slot: i, slots: o, attrs: a, name: "TabGroup" }) } } }); O({ name: "TabList", props: { as: { type: [Object, String], default: "div" } }, setup(t, { attrs: o, slots: a }) { let e = te("TabList"); return () => { let l = { selectedIndex: e.selectedIndex.value }, u = { role: "tablist", "aria-orientation": e.orientation.value }; return I({ props: h(h({}, t), u), slot: l, attrs: o, slots: a, name: "TabList" }) } } }); O({ name: "Tab", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 } }, setup(t, { attrs: o, slots: a }) { let e = te("Tab"), l = `headlessui-tabs-tab-${E()}`, u = g(); B(() => e.registerTab(u)), j(() => e.unregisterTab(u)); let d = S(() => e.tabs.value.indexOf(u)), p = S(() => d.value === e.selectedIndex.value); function i(s) { let v = e.tabs.value.map(b => m(b)).filter(Boolean); if (s.key === " " || s.key === "Enter") { s.preventDefault(), s.stopPropagation(), e.setSelectedIndex(d.value); return } switch (s.key) { case "Home": case "PageUp": return s.preventDefault(), s.stopPropagation(), L(v, 1); case "End": case "PageDown": return s.preventDefault(), s.stopPropagation(), L(v, 8) }return k(e.orientation.value, { vertical() { if (s.key === "ArrowUp") return L(v, 18); if (s.key === "ArrowDown") return L(v, 20) }, horizontal() { if (s.key === "ArrowLeft") return L(v, 18); if (s.key === "ArrowRight") return L(v, 20) } }) } function n() { var s; (s = m(u)) == null || s.focus() } function r() { var s; t.disabled || ((s = m(u)) == null || s.focus(), e.setSelectedIndex(d.value)) } let c = Q(S(() => ({ as: t.as, type: o.type })), u); return () => { var s, v; let b = { selected: p.value }, f = { ref: u, onKeydown: i, onFocus: e.activation.value === "manual" ? n : r, onClick: r, id: l, role: "tab", type: c.value, "aria-controls": (v = (s = e.panels.value[d.value]) == null ? void 0 : s.value) == null ? void 0 : v.id, "aria-selected": p.value, tabIndex: p.value ? 0 : -1, disabled: t.disabled ? !0 : void 0 }; return I({ props: h(h({}, t), f), slot: b, attrs: o, slots: a, name: "Tab" }) } } }); O({ name: "TabPanels", props: { as: { type: [Object, String], default: "div" } }, setup(t, { slots: o, attrs: a }) { let e = te("TabPanels"); return () => { let l = { selectedIndex: e.selectedIndex.value }; return I({ props: t, slot: l, attrs: a, slots: o, name: "TabPanels" }) } } }); O({ name: "TabPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 } }, setup(t, { attrs: o, slots: a }) { let e = te("TabPanel"), l = `headlessui-tabs-panel-${E()}`, u = g(); B(() => e.registerPanel(u)), j(() => e.unregisterPanel(u)); let d = S(() => e.panels.value.indexOf(u)), p = S(() => d.value === e.selectedIndex.value); return () => { var i, n; let r = { selected: p.value }, c = { ref: u, id: l, role: "tabpanel", "aria-labelledby": (n = (i = e.tabs.value[d.value]) == null ? void 0 : i.value) == null ? void 0 : n.id, tabIndex: p.value ? 0 : -1 }; return I({ props: h(h({}, t), c), slot: r, attrs: o, slots: a, features: 3, visible: p.value, name: "TabPanel" }) } } }); function Ht(t) { let o = { called: !1 }; return (...a) => { if (!o.called) return o.called = !0, t(...a) } } function dt() { let t = [], o = [], a = { enqueue(e) { o.push(e) }, requestAnimationFrame(...e) { let l = requestAnimationFrame(...e); a.add(() => cancelAnimationFrame(l)) }, nextFrame(...e) { a.requestAnimationFrame(() => { a.requestAnimationFrame(...e) }) }, setTimeout(...e) { let l = setTimeout(...e); a.add(() => clearTimeout(l)) }, add(e) { t.push(e) }, dispose() { for (let e of t.splice(0)) e() }, async workQueue() { for (let e of o.splice(0)) await e() } }; return a } function ye(t, ...o) { t && o.length > 0 && t.classList.add(...o) } function ie(t, ...o) { t && o.length > 0 && t.classList.remove(...o) } function Wt(t, o) { let a = dt(); if (!t) return a.dispose; let { transitionDuration: e, transitionDelay: l } = getComputedStyle(t), [u, d] = [e, l].map(p => { let [i = 0] = p.split(",").filter(Boolean).map(n => n.includes("ms") ? parseFloat(n) : parseFloat(n) * 1e3).sort((n, r) => r - n); return i }); return u !== 0 ? a.setTimeout(() => o("finished"), u + d) : o("finished"), a.add(() => o("cancelled")), a.dispose } function $e(t, o, a, e, l, u) { let d = dt(), p = u !== void 0 ? Ht(u) : () => { }; return ie(t, ...l), ye(t, ...o, ...a), d.nextFrame(() => { ie(t, ...a), ye(t, ...e), d.add(Wt(t, i => (ie(t, ...e, ...o), ye(t, ...l), p(i)))) }), d.add(() => ie(t, ...o, ...a, ...e, ...l)), d.add(() => p("cancelled")), d.dispose } function W(t = "") { return t.split(" ").filter(o => o.trim().length > 1) } var Te = Symbol("TransitionContext"); function Qt() { return C(Te, null) !== null } function Jt() { let t = C(Te, null); if (t === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."); return t } function Yt() { let t = C(Re, null); if (t === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."); return t } var Re = Symbol("NestingContext"); function be(t) { return "children" in t ? be(t.children) : t.value.filter(({ state: o }) => o === "visible").length > 0 } function pt(t) { let o = g([]), a = g(!1); B(() => a.value = !0), j(() => a.value = !1); function e(u, d = 1) { let p = o.value.findIndex(({ id: i }) => i === u); p !== -1 && (k(d, { [0]() { o.value.splice(p, 1) }, [1]() { o.value[p].state = "hidden" } }), !be(o) && a.value && (t == null || t())) } function l(u) { let d = o.value.find(({ id: p }) => p === u); return d ? d.state !== "visible" && (d.state = "visible") : o.value.push({ id: u, state: "visible" }), () => e(u, 0) } return { children: o, register: l, unregister: e } } var vt = 1, ct = O({ props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(t, { emit: o, attrs: a, slots: e }) { if (!Qt() && Ct()) return () => q(ft, F(h({}, t), { onBeforeEnter: () => o("beforeEnter"), onAfterEnter: () => o("afterEnter"), onBeforeLeave: () => o("beforeLeave"), onAfterLeave: () => o("afterLeave") }), e); let l = g(null), u = g("visible"), d = S(() => t.unmount ? 0 : 1), { show: p, appear: i } = Jt(), { register: n, unregister: r } = Yt(), c = { value: !0 }, s = E(), v = { value: !1 }, b = pt(() => { v.value || (u.value = "hidden", r(s), o("afterLeave")) }); B(() => { let _ = n(s); j(_) }), P(() => { if (d.value === 1 && !!s) { if (p && u.value !== "visible") { u.value = "visible"; return } k(u.value, { hidden: () => r(s), visible: () => n(s) }) } }); let f = W(t.enter), y = W(t.enterFrom), x = W(t.enterTo), w = W(t.entered), T = W(t.leave), A = W(t.leaveFrom), $ = W(t.leaveTo); B(() => { P(() => { if (u.value === "visible") { let _ = m(l); if (_ instanceof Comment && _.data === "") throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?") } }) }); function K(_) { let me = c.value && !i.value, H = m(l); !H || !(H instanceof HTMLElement) || me || (v.value = !0, p.value && o("beforeEnter"), p.value || o("beforeLeave"), _(p.value ? $e(H, f, y, x, w, le => { v.value = !1, le === "finished" && o("afterEnter") }) : $e(H, T, A, $, w, le => { v.value = !1, le === "finished" && (be(b) || (u.value = "hidden", r(s), o("afterLeave"))) }))) } return B(() => { pe([p, i], (_, me, H) => { K(H), c.value = !1 }, { immediate: !0 }) }), D(Re, b), Y(S(() => k(u.value, { visible: 0, hidden: 1 }))), () => { let Pe = t, { appear: _, show: me, enter: H, enterFrom: le, enterTo: al, entered: nl, leave: rl, leaveFrom: ul, leaveTo: il } = Pe, bt = V(Pe, ["appear", "show", "enter", "enterFrom", "enterTo", "entered", "leave", "leaveFrom", "leaveTo"]); return I({ props: F(h({}, bt), { ref: l }), slot: {}, slots: e, attrs: a, features: vt, visible: u.value === "visible", name: "TransitionChild" }) } } }), Zt = ct, ft = O({ inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(t, { emit: o, attrs: a, slots: e }) { let l = G(), u = S(() => t.show === null && l !== null ? k(l.value, { [0]: !0, [1]: !1 }) : t.show); P(() => { if (![!0, !1].includes(u.value)) throw new Error('A <Transition /> is used but it is missing a `:show="true | false"` prop.') }); let d = g(u.value ? "visible" : "hidden"), p = pt(() => { d.value = "hidden" }), i = { value: !0 }, n = { show: u, appear: S(() => t.appear || !i.value) }; return B(() => { P(() => { i.value = !1, u.value ? d.value = "visible" : be(p) || (d.value = "hidden") }) }), D(Re, p), D(Te, n), () => { let r = z(t, ["show", "appear", "unmount"]), c = { unmount: t.unmount }; return I({ props: F(h({}, c), { as: "template" }), slot: {}, slots: F(h({}, e), { default: () => [q(Zt, h(h(h({ onBeforeEnter: () => o("beforeEnter"), onAfterEnter: () => o("afterEnter"), onBeforeLeave: () => o("beforeLeave"), onAfterLeave: () => o("afterLeave") }, a), c), r), e.default)] }), attrs: {}, features: vt, visible: d.value === "visible", name: "Transition" }) } } }); const Xt = O({ name: "BaseModalContainer", components: { TransitionRoot: ft, TransitionChild: ct, Dialog: _t, DialogOverlay: Nt }, emits: ["close"], props: { show: { type: Boolean, required: !0 }, modalColor: { type: String, default: "bg-ne-midPurple" }, maxWidth: { type: String, default: "max-w-3xl" }, outerClose: { type: Boolean, default: !1 } }, methods: { onClose() { !this.outerClose || this.$emit("close") } } }), el = { class: "fixed inset-0 z-30 overflow-y-auto" }, tl = { class: "min-h-screen md:px-4 text-center" }, ll = se("span", { class: "inline-block h-screen align-middle", "aria-hidden": "true" }, " \u200B ", -1); function ol(t, o, a, e, l, u) { const d = ae("DialogOverlay"), p = ae("TransitionChild"), i = ae("Dialog"), n = ae("TransitionRoot"); return Ot(), It(n, { appear: "", show: t.show, as: "template" }, { default: ne(() => [re(i, { as: "div", onClose: t.onClose }, { default: ne(() => [se("div", el, [se("div", tl, [re(p, { as: "template", enter: "duration-300 ease-out", "enter-from": "opacity-0", "enter-to": "opacity-100", leave: "duration-200 ease-in", "leave-from": "opacity-100", "leave-to": "opacity-0" }, { default: ne(() => [re(d, { class: "fixed inset-0 bg-black opacity-70" })]), _: 1 }), ll, re(p, { as: "template", enter: "duration-300 ease-out", "enter-from": "opacity-0 scale-95", "enter-to": "opacity-100 scale-100", leave: "duration-200 ease-in", "leave-from": "opacity-100 scale-100", "leave-to": "opacity-0 scale-95" }, { default: ne(() => [se("div", { class: Et(["h-screen md:h-auto inline-block text-white w-full p-6 overflow-hidden text-left align-middle transition-all transform rounded-md", [t.modalColor, t.maxWidth]]) }, [Tt(t.$slots, "default")], 2)]), _: 3 })])])]), _: 3 }, 8, ["onClose"])]), _: 3 }, 8, ["show"]) } var pl = wt(Xt, [["render", ol]]); export { pl as B };
